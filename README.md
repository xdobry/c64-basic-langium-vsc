# This is Basic Compiler-64 

It reimplement C64 Basic V2 as langium DSL project.

The project contains:

* C64 Basic language server
* Visual Studio C64 Basic plugin
* Code Formater
* Compiler for C64 that produce gcc 64-bit assembler (gas) which can be compiled and linked to executable by using gcc

It is fun project. I have made it to learn langium, x84 assembly language and build my first compiler.

# What is special about langium

C64 Basic was defined are real grammar.
Langium hat good support to make full functional language server for it.
It support validation for keywords, grammar, cross-references und types with immadiatelly display of errors in IDE.

[c64 basic gramar definition](src/language/c-64-basic.langium)

# Alternatives

There is quite a lot alternatives to cross develop C64 Basic on moder platform.
Please check them first.
This project is in early state.

# Structure

You can see following test files

  * examples - examples of c64 basic code that is accepted by the tool.
  * examples_errors - examples of invalid c64 basic code that is recognized by the tool as errornous.
  * examples_compile - c64 basic code examples that can be compiled to 64bit executable
  * generated - GAS assembly code generated by the compiler from examples_comiple files

# Setup and install

You need node js
Use npm or pnpm

* pnpm install
* pnpm run langium:generate
* pnpm run build

# HOW TO Run

From visual studion code

* rebuild language: pnpm run langium:generate
* pnpm run build
* lunch debugger from visuals studio code. Open c64b file (see examples)

# TODO 

## Gramatik Langium

* DATA O-W,

## Langium Funktionality

* Benutzung der Variable for Validierung
* Probleme mit FOR NEXT
* Falsche Benutzung der Variablen (Syntax Error)
* Formatierung
  * Crunch
  * DeCrunch
* Tool Tips
* Basic Original Laden
* Basic Original Speichern

## Valdierung

* Unbenutzte Labels
* Unbenutzte Variablen
* Ein For ohne Next
* GOSUB ohne RETURN
* Unpassende Next
* Falsche Indexe
* Nicht eindeutige Variable Namen

# Compilation to 64 bit GAS

The AST (Abstract Syntax) generated by langium framework is compiled to assebler using typescript
all in one file [Assembler generator from c64 basic](src/cli/generator.ts)

There are also small c-written runtime library for some c64 commands as INPUT or string handling [C-Written runtime](ccode/rtlib.c).
This all is quite minimal so easy to experiment with it.

## String implementation

String as stored as C++String simile structure (pointer *char, lenght and capacity).
The basic string can also store null bytes.
See BString structure in rtlib.c
There are no reference counting.

    A$=B$

This will just reserve new memory and copy the string. The reserved memory is reused if possible.

## Arrays implementation

The arrays memory are allocated lazy (on access). The array structure stores rank and dimensions.
The indexes are checked of boundaries for every access.

## DEF FN implementation

The fn can be redefined.
There are also integer function possible. There must be distinct to float functions.

   DEF FN MINC(X%) = %X+1

## Compile Features to implement

The compiler will break with error if some unsupported keyword is used

* TI$
* OPEN, INPUT#, GET#, PRINT#
* Math Potenz ^
* Can not GET to array GET A$(0)

* TODO 
  - set all stack mem to 0 (init)
  - check division by zero
  - probleme mit parsing label und FOR :AZ=1:....
  - own float and str tmp stack for DEF FN (own local ebp pointer needed?)
  - optimize resuing of str memory

# Optimization

Currently the compiler does not optimize code.
Posible areas

  * reduce expression with constants
  * recognize variable constants
  * encode numeric constant directly to double if only used in double context SIN(2) or 1.2+2
  * remove unnecessary code (variables that are only set but never read)
  * on assembly level (reduce unnecerry moving register to tmp storage and back to register)


# Incompatibilities to C64 Basic

I tried that the compiler produces code that behavious same as possible as original basic 64 interpereter
without the limitations of c64 basic.

Integer and float variables uses 64-bit numbers.
There are no limitiation on string and array dimension length.
The whole variable name is siginificant (not only 2 characters as in c64 basic).

The mathematical expression are also computed directly on integer numbers if 2 operand are also integer.
For loops can use integer variables. If you want to compile the program to x86 you may use more integer variables.
But this will not run on original c64.

For-Next loop might work differently for special cases.
Following code will work on original c64 basic but will not compile with this compiler

   10 GOTO 50
   20 PRINT I: NEXT I
   30 END
   50 FOR I=0 TO 5
   60 GOTO 20

Some commands are not implementated because they make no sense in compiled language or on windows platform.
* RUN
* LIST
* BREAK
* LOAD
* SYS
* VERIFY
* WAIT
* USR
* FRE
* NEW
* CLR

POS, SPC and TAB are fake and not work as suspected. POS gives always 0.

TI pseudo variable gives unix time and it cannot be set.

# Testing

    npm run test

    .\node_modules\.bin\vitest run --testNamePattern "check-compile-files"

For compilation test you need gcc (64 bit) in your path

    $env:PATH += ";C:\devsoft\mingw64win\mingw64\bin"

# Lesson Learned

As I have started the project I have not expected that it will be so hard to get it right and build
real compatible c64 basic compiler.
The first try were very promesing. I could parse and compile hello world basic program into running executable only in 1 day.
But defining the c64 grammar with langium was not so easy to be compatible with original parser.

## Define C64 basic grammar with langium

It is also more difficult than expected.
The parsing of basic is quite easy to program from scratch but tricky in detail and do not match exectly with lexer, grammar approach of regular well designed language.

There problem was also that the tokenizer needs to support different modes if DATA is parsed.
I have needed to hack langium tokenizer to use modes of [chevrotain](https://chevrotain.io/docs/features/lexer_modes.html) lexer.

## How to create executable from source

My knoweldge about building compiler was quite old and I have unfortunatelly started to code without resarching the current state of the art.
Traditionally the compiler emit assembly code from ast (abstract syntax tree).
So I have started to generate [GAS](https://de.wikipedia.org/wiki/GNU_Assembler) assembly code.
This assembly code can be compiled to executable using mingw tool quite easy.
What I have not know is that x64 code for Windows differes from Linux code. This make it quite hard to get right help how to make it right.
I needed to get to know about stack aligning, shadow space and windows x64 [c-calling convention](https://learn.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-170).
Because the programs break a lot I needed to debug at assembly level and learn how to use the debugger.
I have choosen not the easiest tool for it [radare2](https://github.com/radareorg/radare2) (You need 64bit version for debugging).

I have learned a lot about x64 assembly which was my target but it was not the easy way.
At the end the compiler can produce code only for windows x64 bit. And the generator is very platform specific (windows and x64).
The current state of art will be to use some [intermediate represenation](https://en.wikipedia.org/wiki/Intermediate_representation) and reuse existing compiler backend to create platform specific assembly code.
This is done using [llmv](https://llvm.org/) or also (gcc gimple)[https://gcc.gnu.org/onlinedocs/gccint/GIMPLE.html]

At the end the best thing would be just to generate c-code and compile it with gcc or clang to whatever you want.
I whould get the platform independency and optimization for free.
There are planty another options which also could make the things easier: [RPython](https://rpython.readthedocs.io/en/latest/),

The only one good decision was to write runtime code in c. Anyway at the beginning I have not supposed that I need some runtime code anyway because the c64 basic is so easy.

Anyway I have learned much about compiler internals anyway.

## Getting c64 programs to behave the same on windows

This was also the thing that I have expected at the beging but ignored it because it is fun project.
The problem is that very many c64 basic programs are indeed not pure basic programs.
C64 Basic allows to use SYS, PEEK, POKE, WAIT and operate with hardware at very low level.
So the most c64 basic code that you have (for example almost all games) will not run properly after compilation.
This limits the usage of the program a lot.

One could image that write additional compibility layer that maps graphic and memory similar to c64 but at the end
we will have to emulate c64 more and more and the result will be [VICE](https://vice-emu.sourceforge.io/).

So yes. You can make your c64 basic program to real windows executable that will run as fast as possible but only if you use
real basic commands and do not assume c64 hardware.

Anyway there are a lot of teaching and fun c64 basic programs that are indeed not using hardware tricks.
[C64 Example Programs](https://github.com/robfromoz/C64-BASIC)
So you can also have a lot fun with it.


